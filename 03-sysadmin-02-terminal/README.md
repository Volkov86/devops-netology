##               ДЗ к занятию "3.2. Работа в терминале, (лекция 2)" <br/> <br/>


**1.** Какого типа команда cd? Попробуйте объяснить, почему она именно такого типа; опишите ход своих мыслей, если считаете что она могла бы быть другого типа. <br/> <br/>

`cd` (*это команда смены текущего каталога*) <br/>

Название расшифровывается как **change directory.** <br/>
Это команда оболочки **(sh/bash/...)**, а не отдельная программа или системный вызов. <br/> 
Если сделать ее внешней, то она не будет менять каталог в текущей оболочке. <br/> 
Без аргументов — переход в домашний каталог.<br/>
**cd -** возврат в предыдущий каталог. <br/> <br/> 



**2.** Какая альтернатива без pipe команде grep <some_string> <some_file> | wc -l? `man grep`поможет в ответе на этот вопрос. Ознакомьтесь с документом о других подобных некорректных вариантах использования pipe.

`grep <some_string> <some_file> -c` <br/> <br/> <br/> 

**3.** Какой процесс с PID 1 является родителем для всех процессов в вашей виртуальной машине Ubuntu 20.04?

`systemd(1)` <br/> 
[systemd(1)](https://disk.yandex.ru/i/G0B-7Kf0xszEUA)  <br/> <br/>


**4.** Как будет выглядеть команда, которая перенаправит вывод stderr ls на другую сессию терминала? <br/>

`pts/0:` <br/>
`vagrant@ Mon Feb $  ls -l \root 2>/dev/pts/1` <br/>
`vagrant@ Mon Feb $` <br/>
[pts0](https://disk.yandex.ru/i/FW1QpJtg_-62qA) <br/> <br/>
`pts/1:` <br/>
`vagrant@ Mon Feb 07 17:01:27 $  ls: cannot access 'root': No such file or directory` <br/>
[pts1](https://disk.yandex.ru/i/i-q8KGLa2k0YRQ) <br/><br/>


**5.** Получится ли одновременно передать команде файл на `stdin` и вывести ее stdout в другой файл?<br/> Приведите работающий пример. <br/>

`cat < file1.txt > file2.txt` <br/><br/>

**6.** Получится ли вывести находясь в графическом режиме данные из PTY в какой-либо из эмуляторов TTY?<br/> Сможете ли вы наблюдать выводимые данные?<br/>


*Вывести получится при использовании перенаправления вывода:*

`vagrant@ Wed Feb $  tty` <br/>
`/dev/pts/1` <br/>

`vagrant@ Wed Feb $   echo "Hello, World!" > /dev/pts/0` <br/>

`vagrant@ Wed $  tty` <br/>
`/dev/pts/0`<br/>

`vagrant@ Wed $  Hello, World!` <br/>

данные наблюдать не сможем. Чтобы их увидеть надо перейти в эмулятор терминала с помощью Ctrl + Alt + F1..F6 <br/> В моем случает это Ctrl + Alt + F1 <br/><br/>



**7.** Выполните команду bash 5>&1. К чему она приведет? Что будет, если вы выполните echo `netology` > /proc/$$/fd/5? <br/> Почему так происходит?


`bash 5>&1`  создаст дескриптор c **FD5** и перенаправит его в **stdout** <br/> `echo netology > /proc/$$/fd/5` выведет `netology` в дескриптор **"5"**, который был перенаправлен в **stdout.** <br/>
В консоли увидим вывод `netology` <br/>
[fd5](https://disk.yandex.ru/i/8kj2OMFPLbtpxw) <br/><br/>

**8.** Получится ли в качестве входного потока для pipe использовать только stderr команды, не потеряв при этом отображение stdout на pty? <br/> Напоминаем: по умолчанию через pipe передается только stdout команды слева от | на `stdin` команды справа. <br/> Это можно сделать, поменяв стандартные потоки местами через промежуточный новый дескриптор, который вы научились создавать в предыдущем вопросе. <br/>


`ls -l /root 6>&2 2>&1 1>&6 |grep denied -c` <br/> 
1 

`6>&2` - новый дескриптор перенаправили в stderr <br/>
`2>&1` - stderr перенаправили в stdout <br/> 
`1>&6` - stdout - перенаправили в в новый дескриптор <br/> <br/>


**9.** Что выведет команда cat /proc/$$/environ? <br/> Как еще можно получить аналогичный по содержанию вывод?<br/><br/>

`cat /proc/$$/environ` будут выведены переменные окружения <br/> 
[env](https://disk.yandex.ru/i/Rj3XStlgoTQNPw) <br/> 

аналогичный вывод переменных окружения можно получить с помощью команд: <br/> 
`printenv` <br/> 
`env` <br/> <br/> 
так же, при использовании команды `printenv` можно запрашивать значения для отдельных переменных. <br/> 
для просмотра переменных оболочки применяют команду `set` <br/> <br/> 



**10.** Используя man, опишите что доступно по адресам /proc/<PID>/cmdline, /proc/<PID>/exe. <br/> 

`/proc/[pid]/cmdline` <br/> 
этот файл, доступный только для чтения, содержит полный путь до исполняемого файла процесса [PID], если только этот процесс не является зомби.  <br/> В данном примере в этом файле ничего нет, то есть
чтение этого файла вернет **0** символов. <br/>

`/proc/<PID>/exe` <br/>   содержащий фактический путь к выполняемой команде [PID]<br/> попытка открыть его приведет к открытию исполняемого файла. <br/> <br/> 


**11.** Узнайте, какую наиболее старшую версию набора инструкций SSE поддерживает ваш процессор с помощью `/proc/cpuinfo`.

`grep sse /proc/cpuinfo` <br/> 
`cat /proc/cpuinfo` <br/> 
`SSE 4.2` <br/> <br/> 

**12.** При открытии нового окна терминала и vagrant ssh создается новая сессия и выделяется pty. <br/> Это можно подтвердить командой tty, которая упоминалась в лекции 3.2. <br/> Однако: <br/>
vagrant@netology1:~$ ssh localhost 'tty' <br/>
not a tty <br/>
Почитайте, почему так происходит, и как изменить поведение. <br/><br/>
**shell** при входе на удаленный хост предполагает что соединение выполняется пользователем, вводящим команду с помощью клавиатуры. <br/>Для запуска добавляется флаг **-t** и тогда принудительно создается `псевдотерминал`. <br/><br/>


**13.** Бывает, что есть необходимость переместить запущенный процесс из одной сессии в другую. <br/> Попробуйте сделать это, воспользовавшись `reptyr`. Например, так можно перенести в screen процесс, который вы запустили по ошибке в обычной SSH-сессии. <br/><br/>


установим утилиту `reptyr`: (Debian/Ubuntu) <br/>
`sudo apt-get install reptyr` <br/>
`vagrant@ Thu Feb 10 $ top` <br/>
*приостановка процесса* **CTRL-Z** <br/>
`vagrant@ Thu Feb 10 $ bg`   (возобновить процесс в фоновом режиме) <br/>
`vagrant@ Thu Feb 10 $ jobs -l`  (отобразить выполняемые фоновые процессы PID) <br/>
`vagrant@ Thu Feb 10 $ disown 2699` (изолируем дочерний процесс от родительского процесса) <br/>
`vagrant@ Thu Feb 10 $ screen`   (запуск выбранного терминального мультиплексора, например: **tmux,screen**) <br/>
`vagrant@ Thu Feb 10 $ reptyr 2699` (повторное подключение к фоновому процессу) <br/>
`vagrant@ Thu Feb 10 $ proc/sys/kernel/yama/ptrace_scope` (получаем отказ в праве доступа) <br/>
*определяем активное значение с помощью* `cat /proc/sys/kernel/yama/ptrace_scope` <br/>
**1**  (значение разрешает отладку только родительского процесса) <br/>
из под **root** меняем значение `echo 0 > /proc/sys/kernel/yama/ptrace_scope` <br/>
далее процесс будет перехвачен в **screen**, и продолжил работу после закрытия терминала. <br/>
отсоединяем терминальный мультиплексор (например, **CTRL- Z**) и закроем **ssh** <br/>
снова подключаем **ssh**, подключаемся к мультиплексору (например **tmux,screen**) <br/> `screen attach` <br/>
 [screen](https://disk.yandex.ru/i/-eomqWW2doSueA) <br/>
[r pr ](https://disk.yandex.ru/i/SmdQP4SFostk1g) <br/><br/>




**14.** sudo echo string > /root/new_file не даст выполнить перенаправление под обычным пользователем, так как перенаправлением занимается процесс shell'а, который запущен без sudo под вашим пользователем. <br/> Для решения данной проблемы можно использовать конструкцию echo string | sudo tee /root/new_file. <br/> Узнайте что делает команда tee и почему в отличие от sudo echo команда с sudo tee будет работать. <br/>


**tee** читает из `input` и пишет в `output` и в файл <br/>
работает так как команда запущена от **sudo.** <br/>